Reasoned Schemer
* Preface
# <<preface>>
  - A relation, a function that returns a goal as its value, ends its
    name with a superscript `o': (e.g., $car^o$ and $null^o$).
* 1:1 -- 1:53
  #+BEGIN_SRC scheme
    (use mini-kanren)
    
    (run* (q) (== #t q))
    
    (run* (q)
          (conde
           (fail succeed)
           (else fail)))
    
    (run* (q) fail)
    
    (run* (q) fail (== #t q))
    
    (run* (q) succeed (== #t q))
    
    (run* (r) succeed (== 'corn r))
    
    (run* (r) fail (== 'corn r))
    
    (run* (x)
          (let ((x #t))))
    
    (run 2 (x)
         (conde (fail (== 1 x))
                (succeed (== 2 x))
                (else (== 3 x))))
    
    (run* (x) succeed)
    
    (run* (x)
          (conde ((== 'olive x) succeed)
                 ((== 'oil x) fail)
                 (else fail)))
  #+END_SRC
* 1:37
  When one variable is associated with another, we say they /co-refer/
  or /share/.
* 1:48
  =e= in =conde= stands for "every line," since every line can
  succeed.
* 1:54
  =((split pea) (navy bean))=, since both lines are run.

  #+BEGIN_SRC scheme
    (use mini-kanren)
    
    (run* (r)
      (fresh (x y)
        (conde
         ((== 'split x) (== 'pea y))
         ((== 'navy x) (== 'bean y))
         (else fail))
        (== (cons x (cons y '())) r)))
  #+END_SRC
* 1:55
  =((split pea soup) (navy bean soup))=, since =soup= is constant.
* 1:56
  =(tea cup)=, passes to lambda; how to write the null superscript in
  code? Apparently just =o= (e.g. =caro=, =cdro=, &c.).

  #+BEGIN_SRC scheme :tangle kanren-symbols.scm :shebang #!/usr/bin/env chicken-scheme
    (use test)
    (use mini-kanren)
    
    (define teacupo
      (lambda (x)
        (conde ((== 'tea x) succeed)
               ((== 'cup x) succeed)
               (else fail))))
    
    (test '(tea cup)
          (run* (x)
            (teacupo x)))
  #+END_SRC
* 1:57
  #+BEGIN_QUOTE
  The question is the first goal of a line, however the answer is
  the rest of the goals of the line; they must all succeed for the
  line to succeed.
  #+END_QUOTE

  =((tea cup #t) (#f #t))= or =((_.0 #t) (#f #t))= depending on
  whether the question associates the variable (I believe it does)
  after it has been reified; voting for the former.

  #+BEGIN_SRC scheme
    (use mini-kanren test)
    
    (define teacupo
      (lambda (x)
        (conde ((== 'tea x) succeed)
               ((== 'cup x) succeed)
               (else fail))))
    
    (test
     '((tea #t) (cup #t) (#f #t))
     (run* (r)
       (fresh (x y)
         (conde
          ((teacupo x) (== #t y) succeed)
          ((== #f x) (== #t y))
          (else fail))
         (== (cons x (cons y '())) r))))
  #+END_SRC

  Oh, holy shit: =((tea #t) (cup #t) (#f #t))=: for every answer in a
  line, there's a pairwise question-answer variable-association
  (provided that every answer succeeds).

  No, no; scratch that: "From =(teacupo x)=, $x$ gets two
  associations." For every question-association, therefore, there's an
  answer association. ~((teacupo x) (== #t y) (== #t y) succeed)~ has
  the some number of associations; ~((teacupo x) (== #t y) fail (== #t
  y) succeed)~ has none.
* 1:58
  In the first case, ~(== y x)~ succeeds; co-referring =y= and =x=;
  they were already reified in the call to =fresh= above. =y= is
  =_.0=, =x= is =_.1= or =_.0=? =_.0=, apparently (see below), since
  they co-refer.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.0))
     (run* (r)
       (fresh (x y)
         (conde
          ((== y x) succeed))
         (== (cons x (cons y '())) r))))
  #+END_SRC

  =x=, then, gets refreshed as =_.1=; =z=, lastly, as =_.2=. So, =(_.0
  _.2)=. No: =z= and =x= corefer as =_.1=; =(_.0 _.1)=, therefore.

  Secondly, =x= is =_.0=; =y= and =z= corefer as =_.1=. =z= is unified
  with =x=, however, yielding =(_.1 _.0)=.

  Nope: misread; =y= and =x= corefer as =_.0=; =z=, therefore, as
  =_.1=; which yields =((_.0 _.1) (_.0 _.1))=.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.1) (_.0 _.1))
     (run* (r)
       (fresh (x y z)
         (conde
          ((== y x) (fresh (x) (== z x)))
          ((fresh (x) (== y x)) (== z x))
          (else fail))
         (== (cons y (cons z '())) r))))
  #+END_SRC

  Authors mention that "it looks like both occurrences of =_.0= and
  =_.1= have come from the same variable." Is that not the case? In
  the first case, =_.0= is from the outer =x=; in the second, the
  inner =x=. Conversely with =_.1=.
* 1:59
  How does the unification of ~(== #f x)~ interact with =conde=? If
  =conde= binds =x= (which it doesn't: it merely reifies it), ~(== #f
  x)~ should succeed and the result should be the same.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((#f _.0) (_.0 #f))
     (run* (r)
       (fresh (x y z)
         (conde
          ((== y x) (fresh (x) (== z x)))
          ((fresh (x) (== y x)) (== z x))
          (else fail))
         (== #f x)
         (== (cons y (cons z '())) r))))
  #+END_SRC

  Oh, folly; in the first case, of course, =y= and the outer =x=
  corefer, yielding ~(#f _.0)~ (since unbound variables are lazily
  numbered); in the second, =y= and the inner =x= corefer, yielding (I
  think) ~(_.0 #f)~, since the inner =x= is reified but unbound.

  This "clearly shows that the two occurrences of =_.0= in the
  previous frame represent different variables;" is it the case that
  they represent inner and outer =x= like we hypothesized?
* 1:60
  =()=, I think; since =let= binds sequentially and the second
  unification of =#f= and =q= fails.

  #+BEGIN_SRC scheme
    (use debug test mini-kanren)
    
    (run* (q)
      (let ((a (== #t q))
            (b (== #f q)))
        b))
  #+END_SRC

  Oh, clownage: =a= and =b= end up being unification procedures that
  are lazily run?

  "(== #t q) and (== #f q) and expressions, each of whose value is a
  goal. But, here we only /treat/ the (== #f q) expression's value, b,
  as a goal."

  What they call "goals" are e.g. procedures (this is probably a
  flawed analogy, but we'll take it for a working hypothesis).
* 1:61
  Is =conde= merely a goal here, too, or does it get run? I suspect it
  gets run.

  Maybe not: only =b= below is apparently run:

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(2)
     (run* (q)
       (let ((a (conde
                 ((== q q) (== q 3))
                 (else fail)))
             (b (== q 2)))
         b)))
  #+END_SRC

  In that case, I'd posit =(#f)=; since =b= corefers =x= and =q= and
  unifies =#f= with =x=. (We can ignore =a= and =c=.)

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(#f)
     (run* (q)
       (let ((a (== #t q))
             (b (fresh (x)
                  (== x q)
                  (== #f x)))
             (c (conde
                 ((== #t q) succeed)
                 (else ((== #f q))))))
         b)))
  #+END_SRC

  " ~(== ...)~, ~(fresh ...)~, and ~(conde ...)~ are expressions, each
  of whose value is a goal." Lazy eval?
* 2:1
  =c=, where =c= is some scalar or other?

  #+BEGIN_SRC scheme
    (use test)
    
    (test
     'c
     (let ((x (lambda (a) a))
           (y 'c))
       (x y)))
  #+END_SRC
* 2:2
  =(_.0 _.1)=: two reified but unbound variables.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.1))
     (run* (r)
       (fresh (y x)
         (== (list x y) r))))
  #+END_SRC

  Whoops: a list of two reified but unbound variables, i.e. =((_.0
  _.1))=.

  "=(list x y)= is a value, not an expression; could have been built
  with =(cons (reify-name 0) (cons (reify-name 1) '()))=.

  Double whoops (i.e. whoops which negateth whoops): the value
  associated with =r= is indeed =(_.0 _.1)=.
* 2:3
  Similarly, =((_.0 _.1))=; since =x= and =y= corefer to the fresh
  variables =v= and =w=.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.1))
     (run* (r)
       (fresh (v w)
         (== (let ((x v)
                  (y w))
              (list x y))
            r))))
  #+END_SRC
* 2:4
  =grape=
* 2:5
  =a=
* 2:6
  (So =caro= is indeed pronounced "car-oh".)

  I would have said =(a c o r n)=, assuming that =caro= behaves like
  =conde=; but the =e= in =conde= signifies "every line". Do the have
  a =condo=?

  =caro=, being (according to the preface), a "relation, a function
  that returns a goal", might therefore associate =a= with =r=: it's a
  singular goal.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (run* (r)
      (caro '(a c o r n) r))
  #+END_SRC
* 2:7
  =#t= is associated with =r=, since =caro's= goal succeeds; and =q=
  is fresh.

  #+BEGIN_SRC scheme
    (run* (q)
      (caro '(a c o r n) 'a)
      (== #t q))
  #+END_SRC

  Wait a minute: what the fuck is =a=? Oh, =caro= is a goal that
  associates =car= with =a=, somehow.

  Nope: =a= is the goal of =(car '(a c o r n))=; and could just as
  well have failed.
* 2:8
  Could it be that, since =x= is the goal of =r= (and they therefore
  corefer), =pear= is associated with =r=?

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(pear)
     (run* (r)
       (fresh (x y)
         (caro (list r y) x)
         (== 'pear x)
         (== r r))))
  #+END_SRC

  They say "=x= is associated with the =car= of =(r y)=."
* 2:9
  Instead of =caring= =p=, it unifies it with an =a-d= pair.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (define caro
      (lambda (p a)
        (fresh (d)
          (== (cons a d) p))))
    
    (test
     '(#t)
     (run* (q)
       (caro '(a c o r n) 'a)
       (== #t q)))
    
    (test
     '()
     (run* (q)
       (caro '(a c o r n) 'b)))
    
    (test
     '(_.0)
     (run* (q)
       (caro '(a c o r n) 'a)))
  #+END_SRC

  In the case of successful unification, =caro= returns a fresh
  variable; it's a case of unification with multiple values? In other
  words: =a= unifies with =p= successfully, so it returns =d=
  (otherwise =#u=)?

  Heh: "whereas =car= takes one argument, =caro= takes two." Since
  [[preface][=caro= is a relation]], though, /das folgt von sich selbst,/ so to
  speak.
* 2:10
  =(grape a)=
* 2:11
  =(grape a)=, since both =caros= are successful (=x= and =y= being
  fresh).

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((grape a))
     (run* (r)
       (fresh (x y)
         (caro '(grape raisin pear) x)
         (caro '((a) (b) (c)) y)
         (== (cons x y) r))))
  #+END_SRC
* 2:12
  You can use =cons= regardless; but =y= happens to be a list. What
  happens otherwise?

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((grape . a))
     (run* (r)
       (fresh (x y)
         (caro '(grape raisin pear) x)
         (caro '(a b c) y)
         (== (cons x y) r))))
  #+END_SRC

  No big whoop: just a pair.

  Oh, I see: they're referring to the goal/value distinction (or is it
  expression/value?) See 1:49: ". . . expressions, each of whose value
  is a goal [double genitive]."
* 2:13
  =(raisin pear)=
* 2:14
  =c=
* 2:15
  Hmm; on analogy with =cadr=, I'd expect =c=.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(c)
     (run* (r)
       (fresh (v)
         (cdro '(a c o r n) v)
         (caro v r))))
  #+END_SRC

  "Process of transforming =(car (cdr l))= into =(cdro l v)= and
  =(caro v r)= is called /unnesting/. . . . Recognize the simularity
  between unnesting and [CPS]." The inverse of composition?

  See [[http://citeseerx.ist.psu.edu/viewdoc/downloaddoi%3D10.1.1.47.9067&amp%3Brep%3Drep1&amp%3Btype%3Dpdf][this]]:

  #+BEGIN_QUOTE
  In general, the new representation for continuations will save time
  and space when one function makes two or more non-tail calls. In the
  CPS representation, the continuations for these calls will be
  nested. The callee-save convention allows the continuation functions
  to be un-nested and to share a closure. Since all continuation
  functions are nested in some other user functions, the new
  representation for continuations can take advantage of the closure
  of the enclosing user functions if they happen to have some free
  variables in common, thus decreasing the cost of closure record
  constructions.
  #+END_QUOTE
* 2:16
  How does this work?

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (define cdro
      (lambda (p d)
        (fresh (a)
          (== (cons a d) p))))
    
    (test
     '((c o r n))
     (run* (q)
       (cdro '(a c o r n) q)))
    
    (define cdro-with-list
      (lambda (p d)
        (fresh (a)
          (== (list a d) p))))
    
    ;;; (list a d) instead of (cons a d) produces (); how do you explain
    ;;; this behaviour: is it the terminal null which causes
    ;;; pattern-matching to fail?
    (test
     '()
     (run* (q)
       (cdro-with-list '(a c o r n) q)))
    
    ;;; Indeed; this matches:
    (test
     '(c)
     (run* (q)
       (cdro-with-list '(a c) q)))
  #+END_SRC

  I had hypothesized that =caro= truncated the associated variable
  with =(cons a d)=, where =d= is fresh and =a= is =carred=. In this
  case, it unifies =(_.0 . x)= with =(1 2 3 ...)=. (=caro= is =(x .
  _.0)=.)

  The initial =_.0= ends up "deleting" the first element in the case
  of =cdro=? If a =run*= had been somehow interposed, would it delete
  them all?

  =(list a d)= instead of =(cons a d)= returns =()=; is it the case
  that pattern matching against the terminal null causes
  pattern-matching to fail in the unification?

  With a proper list, you have to match exactly $n$ members (where $n$
  is $number-of-fresh-variables$ plus one. Is =a= associated with the
  first element of the list (just as =d= in =caro= is associated with
  the rest)? Can't tell.
