Reasoned Schemer
* Preface
# <<preface>>
  - A relation, a function that returns a goal as its value, ends its
    name with a superscript `o': (e.g., $car^o$ and $null^o$).
* Notes
  [[http://www.cs.indiana.edu/cgi-pub/lkuper/c311/resources#minikanren-resources][Pattern-matching for mini-kanren]]
  #+BEGIN_SRC scheme :tangle mini-kanren-etc.scm
    (use debug test mini-kanren)
  #+END_SRC

  #+BEGIN_SRC scheme
    (use mini-kanren)
    
    (run* (q) (== #t q))
    
    (run* (q)
          (conde
           (fail succeed)
           (else fail)))
    
    (run* (q) fail)
    
    (run* (q) fail (== #t q))
    
    (run* (q) succeed (== #t q))
    
    (run* (r) succeed (== 'corn r))
    
    (run* (r) fail (== 'corn r))
    
    (run* (x)
          (let ((x #t))))
    
    (run 2 (x)
         (conde (fail (== 1 x))
                (succeed (== 2 x))
                (else (== 3 x))))
    
    (run* (x) succeed)
    
    (run* (x)
          (conde ((== 'olive x) succeed)
                 ((== 'oil x) fail)
                 (else fail)))
  #+END_SRC
** Terminology
   - Augend, addend, sum
   - Multiplicand, multiplier, product
   - Dividend, divisor, quotient* 1:1 -- 1:53
** Unification, goals, constraints
   Goals, of which unification is one, are constraints; success means:
   the constraints are mutually consistent. Fail: an inconsistent
   constraint has been introduced.
* 1:37
  When one variable is associated with another, we say they /co-refer/
  or /share/.
* 1:48
  =e= in =conde= stands for "every line," since every line can
  succeed.
* 1:54
  =((split pea) (navy bean))=, since both lines are run.

  #+BEGIN_SRC scheme
    (use mini-kanren)
    
    (run* (r)
      (fresh (x y)
        (conde
         ((== 'split x) (== 'pea y))
         ((== 'navy x) (== 'bean y))
         (else fail))
        (== (cons x (cons y '())) r)))
  #+END_SRC
* 1:55
  =((split pea soup) (navy bean soup))=, since =soup= is constant.
* 1:56
  =(tea cup)=, passes to lambda; how to write the null superscript in
  code? Apparently just =o= (e.g. =caro=, =cdro=, &c.).

  #+BEGIN_SRC scheme :tangle kanren-symbols.scm :shebang #!/usr/bin/env chicken-scheme
    (use test)
    (use mini-kanren)
    
    (define teacupo
      (lambda (x)
        (conde ((== 'tea x) succeed)
               ((== 'cup x) succeed)
               (else fail))))
    
    (test '(tea cup)
          (run* (x)
            (teacupo x)))
  #+END_SRC
* 1:57
  #+BEGIN_QUOTE
  The question is the first goal of a line, however the answer is
  the rest of the goals of the line; they must all succeed for the
  line to succeed.
  #+END_QUOTE

  =((tea cup #t) (#f #t))= or =((_.0 #t) (#f #t))= depending on
  whether the question associates the variable (I believe it does)
  after it has been reified; voting for the former.

  #+BEGIN_SRC scheme
    (use mini-kanren test)
    
    (define teacupo
      (lambda (x)
        (conde ((== 'tea x) succeed)
               ((== 'cup x) succeed)
               (else fail))))
    
    (test
     '((tea #t) (cup #t) (#f #t))
     (run* (r)
       (fresh (x y)
         (conde
          ((teacupo x) (== #t y) succeed)
          ((== #f x) (== #t y))
          (else fail))
         (== (cons x (cons y '())) r))))
  #+END_SRC

  Oh, holy shit: =((tea #t) (cup #t) (#f #t))=: for every answer in a
  line, there's a pairwise question-answer variable-association
  (provided that every answer succeeds).

  No, no; scratch that: "From =(teacupo x)=, $x$ gets two
  associations." For every question-association, therefore, there's an
  answer association. ~((teacupo x) (== #t y) (== #t y) succeed)~ has
  the some number of associations; ~((teacupo x) (== #t y) fail (== #t
  y) succeed)~ has none.

  Albert's experiment:

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (define teacupo
      (lambda (x)
        (conde ((== 'tea x) succeed)
               ((== 'cup x) succeed)
               (else fail))))
    
    (test
     '((tea tea tea)
       (tea tea cup)
       (tea cup tea)
       (tea cup cup)
       (cup tea tea)
       (cup tea cup)
       (cup cup tea)
       (cup cup cup))
     (run* (r)
       (fresh (x y z)
         (conde
          ;; Cartesian product
          ((teacupo x) (teacupo y) (teacupo z) succeed))
         (== (cons x (cons y (cons z '()))) r))))
    
    (test
     '(tea cup)
     (run* (r)
       (fresh (x)
         (conde
          ;; First unification succeeds before the inner conde and passes
          ;; in specific values.
          ((teacupo x) (teacupo x) succeed))
         (== x r))))
    
  #+END_SRC
* 1:58
  In the first case, ~(== y x)~ succeeds; co-referring =y= and =x=;
  they were already reified in the call to =fresh= above. =y= is
  =_.0=, =x= is =_.1= or =_.0=? =_.0=, apparently (see below), since
  they co-refer.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.0))
     (run* (r)
       (fresh (x y)
         (conde
          ((== y x) succeed))
         (== (cons x (cons y '())) r))))
  #+END_SRC

  =x=, then, gets refreshed as =_.1=; =z=, lastly, as =_.2=. So, =(_.0
  _.2)=. No: =z= and =x= corefer as =_.1=; =(_.0 _.1)=, therefore.

  Secondly, =x= is =_.0=; =y= and =z= corefer as =_.1=. =z= is unified
  with =x=, however, yielding =(_.1 _.0)=.

  Nope: misread; =y= and =x= corefer as =_.0=; =z=, therefore, as
  =_.1=; which yields =((_.0 _.1) (_.0 _.1))=.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.1) (_.0 _.1))
     (run* (r)
       (fresh (x y z)
         (conde
          ((== y x) (fresh (x) (== z x)))
          ((fresh (x) (== y x)) (== z x))
          (else fail))
         (== (cons y (cons z '())) r))))
  #+END_SRC

  Authors mention that "it looks like both occurrences of =_.0= and
  =_.1= have come from the same variable." Is that not the case? In
  the first case, =_.0= is from the outer =x=; in the second, the
  inner =x=. Conversely with =_.1=.
* 1:59
  How does the unification of ~(== #f x)~ interact with =conde=? If
  =conde= binds =x= (which it doesn't: it merely reifies it), ~(== #f
  x)~ should succeed and the result should be the same.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((#f _.0) (_.0 #f))
     (run* (r)
       (fresh (x y z)
         (conde
          ((== y x) (fresh (x) (== z x)))
          ((fresh (x) (== y x)) (== z x))
          (else fail))
         (== #f x)
         (== (cons y (cons z '())) r))))
  #+END_SRC

  Oh, folly; in the first case, of course, =y= and the outer =x=
  corefer, yielding ~(#f _.0)~ (since unbound variables are lazily
  numbered); in the second, =y= and the inner =x= corefer, yielding (I
  think) ~(_.0 #f)~, since the inner =x= is reified but unbound.

  This "clearly shows that the two occurrences of =_.0= in the
  previous frame represent different variables;" is it the case that
  they represent inner and outer =x= like we hypothesized?
* 1:60
  =()=, I think; since =let= binds sequentially and the second
  unification of =#f= and =q= fails.

  #+BEGIN_SRC scheme
    (use debug test mini-kanren)
    
    (run* (q)
      (let ((a (== #t q))
            (b (== #f q)))
        b))
  #+END_SRC

  Oh, clownage: =a= and =b= end up being unification procedures that
  are lazily run?

  "(== #t q) and (== #f q) and expressions, each of whose value is a
  goal. But, here we only /treat/ the (== #f q) expression's value, b,
  as a goal."

  What they call "goals" are e.g. procedures (this is probably a
  flawed analogy, but we'll take it for a working hypothesis).
* 1:61
  Is =conde= merely a goal here, too, or does it get run? I suspect it
  gets run.

  Maybe not: only =b= below is apparently run:

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(2)
     (run* (q)
       (let ((a (conde
                 ((== q q) (== q 3))
                 (else fail)))
             (b (== q 2)))
         b)))
  #+END_SRC

  In that case, I'd posit =(#f)=; since =b= corefers =x= and =q= and
  unifies =#f= with =x=. (We can ignore =a= and =c=.)

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(#f)
     (run* (q)
       (let ((a (== #t q))
             (b (fresh (x)
                  (== x q)
                  (== #f x)))
             (c (conde
                 ((== #t q) succeed)
                 (else ((== #f q))))))
         b)))
  #+END_SRC

  " ~(== ...)~, ~(fresh ...)~, and ~(conde ...)~ are expressions, each
  of whose value is a goal." Lazy eval?
* 2:1
  =c=, where =c= is some scalar or other?

  #+BEGIN_SRC scheme
    (use test)
    
    (test
     'c
     (let ((x (lambda (a) a))
           (y 'c))
       (x y)))
  #+END_SRC
* 2:2
  =(_.0 _.1)=: two reified but unbound variables.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.1))
     (run* (r)
       (fresh (y x)
         (== (list x y) r))))
  #+END_SRC

  Whoops: a list of two reified but unbound variables, i.e. =((_.0
  _.1))=.

  "=(list x y)= is a value, not an expression; could have been built
  with =(cons (reify-name 0) (cons (reify-name 1) '()))=.

  Double whoops (i.e. whoops which negateth whoops): the value
  associated with =r= is indeed =(_.0 _.1)=.
* 2:3
  Similarly, =((_.0 _.1))=; since =x= and =y= corefer to the fresh
  variables =v= and =w=.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((_.0 _.1))
     (run* (r)
       (fresh (v w)
         (== (let ((x v)
                  (y w))
              (list x y))
            r))))
  #+END_SRC
* 2:4
  =grape=
* 2:5
  =a=
* 2:6
  (So =caro= is indeed pronounced "car-oh".)

  I would have said =(a c o r n)=, assuming that =caro= behaves like
  =conde=; but the =e= in =conde= signifies "every line". Do the have
  a =condo=?

  =caro=, being (according to the preface), a "relation, a function
  that returns a goal", might therefore associate =a= with =r=: it's a
  singular goal.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     "caro"
     '(a)
     (run* (r)
       (caro '(a c o r n) r)))
  #+END_SRC
* 2:7
  =#t= is associated with =r=, since =caro's= goal succeeds; and =q=
  is fresh.

  #+BEGIN_SRC scheme
    (run* (q)
      (caro '(a c o r n) 'a)
      (== #t q))
  #+END_SRC

  Wait a minute: what the fuck is =a=? Oh, =caro= is a goal that
  associates =car= with =a=, somehow.

  Nope: =a= is the goal of =(car '(a c o r n))=; and could just as
  well have failed.
* 2:8
  Could it be that, since =x= is the goal of =r= (and they therefore
  corefer), =pear= is associated with =r=?

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(pear)
     (run* (r)
       (fresh (x y)
         (caro (list r y) x)
         (== 'pear x)
         (== r r))))
  #+END_SRC

  They say "=x= is associated with the =car= of =(r y)=."
* 2:9
  Instead of =caring= =p=, it unifies it with an =a-d= pair.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (define caro
      (lambda (p a)
        (fresh (d)
          (== (cons a d) p))))
    
    (test
     '(#t)
     (run* (q)
       (caro '(a c o r n) 'a)
       (== #t q)))
    
    (test
     '()
     (run* (q)
       (caro '(a c o r n) 'b)))
    
    (test
     '(_.0)
     (run* (q)
       (caro '(a c o r n) 'a)))
  #+END_SRC

  In the case of successful unification, =caro= returns a fresh
  variable; it's a case of unification with multiple values? In other
  words: =a= unifies with =p= successfully, so it returns =d=
  (otherwise =#u=)?

  Heh: "whereas =car= takes one argument, =caro= takes two." Since
  [[preface][=caro= is a relation]], though, /das folgt von sich selbst,/ so to
  speak.
* 2:10
  =(grape a)=
* 2:11
  =(grape a)=, since both =caros= are successful (=x= and =y= being
  fresh).

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((grape a))
     (run* (r)
       (fresh (x y)
         (caro '(grape raisin pear) x)
         (caro '((a) (b) (c)) y)
         (== (cons x y) r))))
  #+END_SRC
* 2:12
  You can use =cons= regardless; but =y= happens to be a list. What
  happens otherwise?

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '((grape . a))
     (run* (r)
       (fresh (x y)
         (caro '(grape raisin pear) x)
         (caro '(a b c) y)
         (== (cons x y) r))))
  #+END_SRC

  No big whoop: just a pair.

  Oh, I see: they're referring to the goal/value distinction (or is it
  expression/value?) See 1:49: ". . . expressions, each of whose value
  is a goal [double genitive]."
* 2:13
  =(raisin pear)=
* 2:14
  =c=
* 2:15
  Hmm; on analogy with =cadr=, I'd expect =c=.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     "cdro"
     '(c)
     (run* (r)
       (fresh (v)
         (cdro '(a c o r n) v)
         (caro v r))))
  #+END_SRC

  "Process of transforming =(car (cdr l))= into =(cdro l v)= and
  =(caro v r)= is called /unnesting/. . . . Recognize the simularity
  between unnesting and [CPS]." The inverse of composition?

  See [[http://citeseerx.ist.psu.edu/viewdoc/downloaddoi%3D10.1.1.47.9067&amp%3Brep%3Drep1&amp%3Btype%3Dpdf][this]]:

  #+BEGIN_QUOTE
  In general, the new representation for continuations will save time
  and space when one function makes two or more non-tail calls. In the
  CPS representation, the continuations for these calls will be
  nested. The callee-save convention allows the continuation functions
  to be un-nested and to share a closure. Since all continuation
  functions are nested in some other user functions, the new
  representation for continuations can take advantage of the closure
  of the enclosing user functions if they happen to have some free
  variables in common, thus decreasing the cost of closure record
  constructions.
  #+END_QUOTE
* 2:16
  How does this work?

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (define cdro
      (lambda (p d)
        (fresh (a)
          (== (cons a d) p))))
    
    (test
     '((c o r n))
     (run* (q)
       (cdro '(a c o r n) q)))
    
    (define cdro-with-list
      (lambda (p d)
        (fresh (a)
          (== (list a d) p))))
    
    ;;; (list a d) instead of (cons a d) produces (); how do you explain
    ;;; this behaviour: is it the terminal null which causes
    ;;; pattern-matching to fail?
    (test
     '()
     (run* (q)
       (cdro-with-list '(a c o r n) q)))
    
    ;;; Indeed; this matches:
    (test
     '(c)
     (run* (q)
       (cdro-with-list '(a c) q)))
  #+END_SRC

  I had hypothesized that =caro= truncated the associated variable
  with =(cons a d)=, where =d= is fresh and =a= is =carred=. In this
  case, it unifies =(_.0 . x)= with =(1 2 3 ...)=. (=caro= is =(x .
  _.0)=.)

  The initial =_.0= ends up "deleting" the first element in the case
  of =cdro=? If a =run*= had been somehow interposed, would it delete
  them all?

  =(list a d)= instead of =(cons a d)= returns =()=; is it the case
  that pattern matching against the terminal null causes
  pattern-matching to fail in the unification?

  With a proper list, you have to match exactly $n$ members (where $n$
  is $number-of-fresh-variables$ plus one. Is =a= associated with the
  first element of the list (just as =d= in =caro= is associated with
  the rest)? Can't tell.
* 2:17
  =((raisin pear) a)=
* 2:18
  =((raisin pear) a)= by analogy.

  #+BEGIN_SRC scheme
    (use test mini-kanren)
    
    (test
     '(((raisin pear) a))
     (run* (r)
       (fresh (x y)
         (cdro '(grape raisin pear) x)
         (caro '((a) (b) (c)) y)
         (== (cons x y) r))))
  #+END_SRC
* 2:19
  =#t= should be associated with =q= since the =cdro= succeeds.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(#t)
     (run* (q)
       (cdro '(a c o r n) '(c o r n))
       (== #t q)))
  #+END_SRC
* 2:20
  Initial hypothesis: =x= is empty because =cdro= fails.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(o)
     (run* (x)
       (cdro '(c o r n) `(,x r n))))
  #+END_SRC

  Damn; which is not the case: =o=. Due to the (permissive) pattern
  matching, =x= matches =o=; I might have so =(c o)=, but the matching
  isn't greedy.

  "Because =(o r n)= is the =cdr= of =(c o r n)=."

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '()
     (run* (x)
       (== '(c o r n) `(,x r n))))
    
    (test
     '(o)
     (run* (x)
       (fresh (y)
         (== '(c o r n) `(,y ,x r n)))))
    
    (test
     '(o)
     (run* (x)
       (== '(c o r n) `(c ,x r n))))
  #+END_SRC

  Unification isn't greedy, either.
* 2:21
  Possibly =(a o r n)=, if =x= is associated with the =car= of =l=;
  and =l= is associated with the =cdr= of =(c o r n)=.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((a c o r n))
     (run* (l)
       (fresh (x)
         (cdro l '(c o r n))
         (caro l x)
         (== 'a x))))
    
  #+END_SRC

  =(a c o r n)=: ouch; how is this possible? Going back to the
  definition of =cdro= and =caro=, however, we have =(_.0 c o r n)=
  and =(x _.0)=; the unification of which is: =(a c o r n)=? Jesus.

  Indeed: the =cdr= of =l= is =(c o r n)= (hence =(_.0 c o r n)=); but
  =l= is not the =cdr= of =(c o r n)=.

  Also, =x= corefers to the =car= of =l=, =(_.0 c o r n)=: =_.0=;
  doesn't it? Therefore, unifying with =x= modifies =l=.

  =cdro=, =caro=, &c. putting constraints on =l=; at unification time,
  it either passes those constraints ("succeeds") or doesn't; =a= is a
  datum.
* 2:22
  On analogy with =cons=, =(a b c d e)=; for every goal-function
  ending in =o=, some variable is specified to associate with that
  goal (when the goals are "unified", they are finally given the
  opportunity to succeed or fail). Or maybe when the goals are simply
  "run"; unification is something else: an assertion; an association?

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(((a b c) d e))
     (run* (l)
       (conso '(a b c) '(d e) l)))
  #+END_SRC

  Sorry: =((a b c) d e)=.
* 2:23
  According to pattern matching, =d= is associated with =x=.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(d)
     (run* (x)
       (conso x '(a b c) '(d a b c))))
  #+END_SRC

  =conso= is a goal; when run, =x= passed the constraints of its
  goal(s) and yielded (was associated with) a value.
* 2:24
  =r= \to =(e a d x)=; =c= \to $x$; $z$ \to =d=; and finally, $y$ is
  associated with the decons (i.e. difference) of =(e a d c)= and =(a
  d c)= \to =e=.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((e a d c))
     (run* (r)
       (fresh (x y z)
         (== `(e a d ,x) r)
         (conso y `(a ,z c) r))))
  #+END_SRC
* 2:25
  =d=; interestingly, after satisfasfying the =conso= constraint, do
  =(a x c)= and =(d a x c)= "become" =(a d c)=, =(d a d c)=,
  respectively? Insofar as the refer to $x$, possibly; how to test
  this?

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(d)
     (run* (x)
       (conso x `(a ,x c) `(d a ,x c))))
  #+END_SRC
* 2:26
  =(d a d c)=: =d= matches positions 1 and 3 without conflict.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((d a d c))
     (run* (l)
       (fresh (x)
         (== `(d a ,x c) l)
         (conso x `(a ,x c) l))))
  #+END_SRC

  [[http://en.wikipedia.org/wiki/Parataxis][Parataxically]] (as opposed to [[http://en.wikipedia.org/wiki/Hypotaxis][hypotaxically]] speaking): the $x$ in $l$
  (=(d a x c)=) is associated with =d=.
* 2:27
  =(d a d c)=: the first $x$ (=._0=) in $l$ (=(x a x c)=) is
  associated with =d=; and therefore the second $x$.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((d a d c))
     (run* (l)
       (fresh (x)
         (conso x `(a ,x c) l)
         (== `(d a ,x c) l))))
  #+END_SRC

  (The authors describe it threefold: =cons=, associate, associate.)
* 2:28
  =conso= takes three arguments:[fn:1] the consend, consor and cons.
  Can we attempt to unify a cons of the consend and consor with the
  cons?

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (define conso
      (lambda (consend consor pair)
        (== (cons consend consor) pair)))
    
    (test
     '((a . d))
     (run* (l)
       (conso 'a 'd l)))
  #+END_SRC

  The authors use $a$, $d$ and $p$ instead of $consend$, $consor$,
  $cons*$.
* 2:29
  =(b e a n s)=: $s$ is associated with =(_.0 a n s)=; $l$ is
  associated with =(_.1 _.0 a n s)=; $x$ is associated with =_.1= (the
  car of $l$) and finally with =b=.

  $d$ is associated with =(_.0 a n s)=, the =cdr= of $l$;[fn:2] $y$
  associated with =_.0= and finally with =e=.

  $l$ is associated with =(b e a n s)=.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((b e a n s))
     (run* (l)
       (fresh (d x y w s)
         (conso w '(a n s) s)
         (cdro l s)
         (caro l x)
         (== 'b x)
         (cdro l d)
         (caro d y)
         (== 'e y))))
  #+END_SRC

  It turns out that $d$ and $s$ do indeed corefer:

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((b e a n s))
     (run* (l)
       (fresh (d x y w s)
         (conso w '(a n s) s)
         (cdro l s)
         (caro l x)
         (== 'b x)
         (caro s y)
         (== 'e y))))
  #+END_SRC
  
  And, for that matter, $w$ and $l$:

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((b e a n s))
     (run* (l)
       (fresh (d x y w s)
         (conso w '(a n s) s)
         (cdro l s)
         (caro l x)
         (== 'b x)     
         (== 'e w))))
  #+END_SRC
* 2:30
  =#f=
* 2:31
  =#t=
* 2:32
  =()=, since the =nullo= goal fails.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '()
     (run* (q)
       (nullo '(grape raisin pear))
       (== #t q)))
  #+END_SRC
* 2:33
  =(#t)=, since =nullo= and the unification of $q$ succeed.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(#t)
     (run* (q)
       (nullo '())
       (== #t q)))
  #+END_SRC
* 2:34
  Is a fresh variable null? Not necessarily; I hypothesize that
  =nullo= fails.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(())
     (run* (x)
       (nullo x)))
  #+END_SRC

  Did =nullo= fail? If so, why an embedded list?

  =(nullo x)=, where $x$ is fresh, succeeds because it hasn't violated
  any constraints: it does not say, however, whether $x$ is actually
  null. $x$ is [[http://en.wikipedia.org/wiki/Schr%C3%B6dinger's_cat][Schrödinger's cat]], as long as it's fresh.

  On the other hand, a unification takes place; $x$ is therefore no
  longer fresh afterwards? Indeed. Therefore: =nullo=, =caro=,
  =cadro=, &c. are forms of destructive observation, i.e.
  constraint-setters.
* 2:35
  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (define nullo
      (lambda (x)
        (== x '())))
    
    (test
     '()
     (run* (q)
       (nullo '(grape raisin pear))
       (== #t q)))
    
    (test
     '(#t)
     (run* (q)
       (nullo '())
       (== #t q)))
    
    (test
     '(())
     (run* (x)
       (nullo x)))
  #+END_SRC
* 2:36
  =#f=
* 2:37
  =#t=
* 2:38
  =()=, because the =eqo= goal fails.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     "eqo on unequal symbols"
     '()
     (run* (q)
       (eqo 'pear 'plum)
       (== #t q)))
  #+END_SRC
* 2:39
  =(#t)=, because the =eqo= goal succeeds; and so does the unification
  of =#t= with $q$.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     "eqo on equal symbols"
     '(#t)
     (run* (q)
       (eqo 'plum 'plum)
       (== #t q)))
  #+END_SRC
* 2:40
  Does it suffice merely to unify $x$ and $y$?

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (define eqo
      (lambda (x y)
        (== x y)))
    
    (test
     "eqo on unequal symbols"
     '()
     (run* (q)
       (eqo 'pear 'plum)
       (== #t q)))
    
    (test
     "eqo on equal symbols"
     '(#t)
     (run* (q)
       (eqo 'plum 'plum)
       (== #t q)))
  #+END_SRC

  Apparently.
* 2:41
  Yes
* 2:42
  Yes
* 2:43
  =#t=
* 2:44
  =#f=
* 2:45
  No
* 2:46
  No
* 2:47
  Yes
* 2:48
  =pear=
* 2:49
  =()=
* 2:50
  =cons=
* 2:51
  =((split) . pea)=
* 2:52
  =(_.0 _.1 . salad)=.
  
  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '((_.0 _.1 . salad))
     (run* (r)
       (fresh (x y)
         (== (cons x (cons y 'salad)) r))))
  #+END_SRC

  Whoops: =((_.0 _.1 . salad))=.
* 2:53
  No, I don't think so; =conso= reduces to a unification using =cons=
  and without =pairo=.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (define pairo
      (lambda (p)
        (fresh (a d)
          (conso a d p))))
    
    (test
     '(#t)
     (run* (q)
       (pairo '(a . b))
       (== #t q)))
  #+END_SRC

  =pairo= detects, essentially, whether =p= can be destructured into
  =car= and =cdr=.

  (=a=, =d=, =p=, incidentally, stand for "address", "decrement" and
  "pair;" I believe.)
* 2:54
  =(#t)=, since the =pairo= goal succeeds and so does the following
  unification.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(#t)
     (run* (q)
       (pairo (cons q q))
       (== #t q)))
  #+END_SRC
* 2:55
  =()=, since =pairo= fails.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '()
     (run* (q)
       (pairo '())
       (== #t q)))
  #+END_SRC
* 2:56
  =()=, since =pairo= fails.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '()
     (run* (q)
       (pairo 'pair)
       (== #t q)))
  #+END_SRC
* 2:57
  =_.0=; since $r$, itself fresh, is unified with a fresh variable in
  =conso= (over =pairo=).

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (test
     '(_.0)
     (run* (r)
       (pairo (cons r 'pear))))
  #+END_SRC

  Is this an example of non-destructive unification? Non-destructive
  unification is unification, I suppose, with a fresh variable; and
  fresh-on-fresh yields fresh.
* 2:58
  That =pairo= can be defined from =conso= is already manifest in
  [[2:52]]; =cdro= and =caro= should be definable in terms of =conso=,
  too.

  #+BEGIN_SRC scheme
    (include "mini-kanren-etc.scm")
    
    (define caro
      (lambda (p a)
        (fresh (d)
          (conso a d p))))
    
    (define cdro
      (lambda (p d)
        (fresh (a)
          (conso a d p))))
    
    (test
     "caro based on conso"
     '(a)
     (run* (r)
       (caro '(a c o r n) r)))
    
    (test
     "cdro based on conso"
     '(c)
     (run* (r)
       (fresh (v)
         (cdro '(a c o r n) v)
         (caro v r))))
  #+END_SRC
* 3:1
  =(list? '((a) (a b) c))= \to =#t=, since the final element of the
  list is =null?=.
* 3:2
  =(list? ())= \to =#t=, since the final element of the list is
  =null?=.
* 3:3
  =(list? 's)= \to =#f=, since the final element is not =null?=.
* 3:4
  =(list? '(d a t e . s))= \to =#f=, since the final element is not
  =null?=.
* 3:5
  Besides the superficial differences of =#t=, =#f= vs. =#s=, =#u=,
  &c.; the recursive call to =listo= (i.e. the =pairo= arm) is
  parataxically (i.e. sequentially) not hypotaxically (i.e.
  compositionally) expressed.
* Footnotes

[fn:1] Danenberg, Peter (klutometis). "On analogy with augend, addend,
  sum; multiplicand, multiplier, product; &c., the elements of a cons
  operation are: consend, consor, cons." 8 March 12, 4:32 p.m. Tweet.

[fn:2] Why not with $s$, by the way, the former =cdr= of $l$: do they
  not corefer? They do, apparently: =(caro s y)= works just as well.
